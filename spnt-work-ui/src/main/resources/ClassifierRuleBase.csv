"#id";"rule";"action";"description"
1;"currentSegment == null && ctx.featureInMax";"processNoise";"Current not initialized. Found max, but there is no min. skip it"
2;"currentSegment == null";"initSegment";"Current not initialized. This first segment"
3;"ctx.featureStable && currentSegment == null";"processNoise";"initial noise"
4;"ctx.featureStable && stableLength <20";"processSignal";"waiting for decision if this part of signal"
5;"ctx.featureStable && stableLength >20 && currentPeakCount > 0";"changePoint";"this is part of noise"
6;"ctx.featureStable && stableLength >20 ";"processNoise";"this is part of noise"
7;"ctx.featureInMin";"changePoint";"change point"
8;"ctx.featureInMax && lastLength < 20 ";"join";"too small last"
9;"ctx.featureInMax && distanceBetweenPaeks<40";"join";"Found max. join as between peaks not enough space"
10;"ctx.featureInMax && isIncrease && distanceBetweenPaeks<40";"join";"Found max. join as increase"
"#11";"ctx.featureInMax && isDecrease && distanceBetweenPaeks<80";"join";"Found max. join as decrease"
12;"ctx.featureInMax && ""0"".equals(className) ";"delete";"too small last"
13;"ctx.featureInMax && lastSegment.start < 100";"delete";"remove initial"
14;"ctx.featureInMax";"changePointLastApproved";"Found max. approve previous change point"
15;"true";"processSignal";"Rule not match"