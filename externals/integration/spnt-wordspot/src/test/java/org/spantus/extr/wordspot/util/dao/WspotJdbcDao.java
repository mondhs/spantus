/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.spantus.extr.wordspot.util.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.MessageFormat;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map.Entry;
import java.util.Set;

import org.spantus.core.beans.RecognitionResult;
import org.spantus.core.beans.SignalSegment;
import org.spantus.core.marker.Marker;
import org.spantus.exception.ProcessingException;
import org.spantus.extr.wordspot.dto.MarkerPair;
import org.spantus.extr.wordspot.dto.MatchFoundDto;
import org.spantus.extractor.impl.ExtractorEnum;
import org.spantus.utils.Assert;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;

/**
 * 
 * @author mondhs
 */
public class WspotJdbcDao {

	Connection connection = null;
	Statement statement = null;
	boolean recreate = false;

	public void init() {
		try {
			Class.forName("org.hsqldb.jdbcDriver").newInstance();

			String url = "jdbc:hsqldb:hsql://localhost/spnt-exp";
			connection = DriverManager.getConnection(url, "sa", "");
			connection.setAutoCommit(true);

			statement = connection.createStatement();
			if (recreate) {
				String query = "DROP TABLE WordSpotInfoExp IF EXISTS;"
						+ "CREATE CACHED TABLE WordSpotInfoExp("
						+ "id BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 0) NOT NULL PRIMARY KEY,"
						+ "fileName VARCHAR(255) NOT NULL,"
						+ "proccessingLength BIGINT, "
						+ "experimentStarted BIGINT,"
						+ "experimentEnded  BIGINT,"
						+ "audioLength  BIGINT,"
						+ "OPERATIONCOUNT BIGINT,"
						+ ");"
						+ "DROP TABLE WordSpotFoundExp IF EXISTS;"
						+ "CREATE CACHED TABLE WordSpotFoundExp("
						+ "id BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 0) NOT NULL PRIMARY KEY,"
						+ "ekey VARCHAR(255) NOT NULL,"
						+ "fileName VARCHAR(255) NOT NULL,"
						+ "markerLabel VARCHAR(255),"
						+ "markerStart BIGINT,"
						+ "markerEnd BIGINT,"
						+ "foundStart BIGINT,"
						+ "foundEnd BIGINT,"
						+ "mfccValue FLOAT);"
						+ "\n"
						+ "DROP TABLE WordSpotSampleExp IF EXISTS;"
						+ "CREATE CACHED TABLE WordSpotSampleExp("
						+ "id BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 0) NOT NULL PRIMARY KEY,"
						+ "ekey VARCHAR(255) NOT NULL UNIQUE,"
						+ "fileName VARCHAR(255) NOT NULL,"
						+ "markerLabel VARCHAR(255) NOT NULL,"
						// + "proccessingLength BIGINT, "
						// + "experimentStarted BIGINT,"
						// + "experimentEnded  BIGINT,"
						// + "audioLength  BIGINT,"
						+ "markerStart BIGINT," + "markerEnd BIGINT," + ");";
				statement.executeUpdate(query);
				connection.commit();
			}

		} catch (InstantiationException | IllegalAccessException
				| ClassNotFoundException | SQLException e) {
			destroy();
			throw new ProcessingException(e);
		}
	}

	public void save(WordSpotResult result) {
		String fileName = result.getFileName();
		insertExpInfo(result);

		Set<Marker> orignalSet = transformAndSaveExistingSamples(result,
				fileName);
		MatchFoundDto matchFoundDto = matchFoundWithExiting(result, orignalSet);
		saveFoundSamples(result, fileName, matchFoundDto);
		saveNotFoundSamples(fileName, matchFoundDto);
		saveFoundDuplicateSamples(fileName, matchFoundDto);

	}

	/**
	 * 
	 * @param result
	 * @param orignalSet
	 * @return
	 */
	private MatchFoundDto matchFoundWithExiting(WordSpotResult result,
			Set<Marker> orignalSet) {
		MatchFoundDto matchFound = new MatchFoundDto();
		matchFound.matchBi = HashBiMap.create();
		matchFound.duplicates = new HashSet<Marker>();

		for (Entry<RecognitionResult, SignalSegment> recognitionResultEntry : result
				.getSegments().entrySet()) {

			SignalSegment signalSegment = recognitionResultEntry.getValue();
			Marker m = signalSegment.getMarker();
			MarkerPair closestPair = findClosestMarker(orignalSet,
					signalSegment.getMarker());
			Marker alreadyExisits = matchFound.matchBi.inverse().get(
					closestPair.originalMarker);
			if (alreadyExisits != null) {
				long existingResult = Math.abs(calculateDelta(
						closestPair.originalMarker, alreadyExisits));
				if (existingResult > closestPair.delta) {
					matchFound.duplicates.add(alreadyExisits);
					matchFound.matchBi.remove(alreadyExisits);
					matchFound.matchBi.put(m, closestPair.originalMarker);
				} else {
					matchFound.duplicates.add(m);
				}
			} else {
				matchFound.matchBi.put(m, closestPair.originalMarker);
			}
		}

		matchFound.notFound = new HashSet<>(orignalSet);
		matchFound.notFound.removeAll(matchFound.matchBi.values());

		return matchFound;
	}

	private void saveFoundDuplicateSamples(String fileName,
			MatchFoundDto matchFoundDto) {
		for (Marker duplicateMarker : matchFoundDto.duplicates) {
			String foundLabel = fixLabel(duplicateMarker.getLabel());
			Long foundStart = duplicateMarker.getStart();
			Long foundEnd = duplicateMarker.getEnd();
			String insertQuery = "INSERT INTO WordSpotFoundExp (EKEY, FILENAME, MARKERLABEL, MARKERSTART,MARKEREND,FOUNDSTART,FOUNDEND,MFCCVALUE) VALUES "
					+ "(''{0}-{8}-{2}'', ''{0}'' , ''{1}'',null,"
					+ "null,{5,number,#},{6,number,#},{7,number,#.###});";

			String queryWORDSPOTEXP = MessageFormat.format(insertQuery,
					fileName, foundLabel, duplicateMarker.getId(), 0, 0,
					foundStart, foundEnd, 0, duplicateMarker.getLabel());
			insert(queryWORDSPOTEXP);
		}
	}

	/**
	 * 
	 * @param fileName
	 * @param matchFoundDto
	 */
	private void saveNotFoundSamples(String fileName,
			MatchFoundDto matchFoundDto) {
		for (Marker notFoundMarker : matchFoundDto.notFound) {
			String markerLabel = fixLabel(notFoundMarker.getLabel());
			Long markerStart = notFoundMarker.getStart();
			Long markerEnd = notFoundMarker.getEnd();
			String insertQuery = "INSERT INTO WordSpotFoundExp (EKEY, FILENAME, MARKERLABEL, MARKERSTART,MARKEREND,FOUNDSTART,FOUNDEND,MFCCVALUE) VALUES "
					+ "(''{0}-{8}-{2}'', ''{0}'' , ''{1}'',{3,number,#},"
					+ "{4,number,#},null,null,null);";

			String queryWORDSPOTEXP = MessageFormat.format(insertQuery,
					fileName, notFoundMarker.getLabel(),
					notFoundMarker.getId(), markerStart, markerEnd, 0, 0, 0,
					markerLabel);
			insert(queryWORDSPOTEXP);
		}
	}

	/**
	 * 
	 * @param result
	 * @param fileName
	 * @param orignalSet
	 * @return
	 */
	private void saveFoundSamples(WordSpotResult result, String fileName,
			MatchFoundDto matchFoundDto) {

		// Set<Marker> foundSet = new LinkedHashSet<Marker>();

		for (Entry<RecognitionResult, SignalSegment> recognitionResultEntry : result
				.getSegments().entrySet()) {

			RecognitionResult recognitionResult = recognitionResultEntry
					.getKey();
			SignalSegment signalSegment = recognitionResultEntry.getValue();
			Marker marker = signalSegment.getMarker();

			Marker closest = matchFoundDto.matchBi.get(marker);
			if (closest == null && matchFoundDto.duplicates.contains(marker)) {
				// store as duplicated
				continue;
			}
			Assert.isTrue(closest != null, "Not found for {0}", marker);

			Long foundStart = marker.getStart();
			Long foundEnd = marker.getEnd();
			String foundLabel = fixLabel(marker.getLabel());
			Double mfccValue = 0D;
			if (recognitionResult.getDetails() != null) {
				mfccValue = recognitionResult.getDetails().getDistances()
						.get(ExtractorEnum.MFCC_EXTRACTOR.name());
			}

			Long markerStart = closest.getStart();
			Long markerEnd = closest.getEnd();

			String insertQuery = "INSERT INTO WordSpotFoundExp (EKEY, FILENAME, MARKERLABEL, MARKERSTART,MARKEREND,FOUNDSTART,FOUNDEND,MFCCVALUE) VALUES "
					+ "(''{0}-{8}-{2}'', ''{0}'' , ''{1}'',{3,number,#},"
					+ "{4,number,#},{5,number,#},{6,number,#},{7,number,#.###});";

			String queryWORDSPOTEXP = MessageFormat.format(insertQuery,
					fileName, foundLabel, closest.getId(), markerStart,
					markerEnd, foundStart, foundEnd, mfccValue,
					closest.getLabel());
			insert(queryWORDSPOTEXP);
		}
	}

	/**
	 * 
	 * @param result
	 * @param fileName
	 * @return
	 */
	private Set<Marker> transformAndSaveExistingSamples(WordSpotResult result,
			String fileName) {
		Set<Marker> orignalSet = new LinkedHashSet<Marker>();

		for (Marker originalMarker : result.getOriginalMarker()) {
			String markerLabel = fixLabel(originalMarker.getLabel());
			Long markerStart = originalMarker.getStart();
			Long markerEnd = originalMarker.getEnd();
			orignalSet.add(originalMarker);

			String insertWordSpotSampleExpQuery = "INSERT INTO WordSpotSampleExp ("
					+ "EKEY, FILENAME, MARKERLABEL,MARKERSTART,MARKEREND) VALUES "
					+ "(''{0}-{1}-{2}'', ''{0}'',  ''{1}'' ,{3,number,#},"
					+ "{4,number,#});";

			String queryWordSpotSampleExp = MessageFormat.format(
					insertWordSpotSampleExpQuery, fileName, markerLabel,
					originalMarker.getId(), markerStart, markerEnd);

			insert(queryWordSpotSampleExp);
		}
		return orignalSet;
	}

	/**
	 * 
	 * @param markerLabel
	 * @return
	 */
	private String fixLabel(String markerLabel) {
		return markerLabel.replaceAll("[\'|-]", "");
	}

	/**
	 * 
	 * @param orignalSet
	 * @param foundStart
	 * @return
	 */
	private MarkerPair findClosestMarker(Set<Marker> orignalSet,
			Marker foundMarker) {
		Marker closestMarker = null;
		Long minDelta = Long.MAX_VALUE;
		for (Marker iOriginalMarker : orignalSet) {
			long delta = Math.abs(calculateDelta(iOriginalMarker, foundMarker));
			if (delta < minDelta) {
				minDelta = delta;
				closestMarker = iOriginalMarker;

			}
		}
		MarkerPair pair = null;
		if (closestMarker != null) {
			pair = new MarkerPair();
			pair.delta = minDelta;
			pair.foundMarker = foundMarker;
			pair.originalMarker = closestMarker;
		}
		return pair;
	}

	/**
	 * 
	 * @param originalMarker
	 * @param foundMarker
	 * @return
	 */
	private long calculateDelta(Marker originalMarker, Marker foundMarker) {
		long centerOriginal = originalMarker.getStart()
				+ (originalMarker.getLength() / 2);
		long centerFound = foundMarker.getStart()
				+ (foundMarker.getLength() / 2);
		return centerOriginal - centerFound;
	}

	/**
	 * 
	 * @param result
	 */
	private void insertExpInfo(WordSpotResult result) {
		String fileName = result.getFileName();
		long proccessinglength = result.getExperimentEnded()
				- result.getExperimentStarted();
		long experimentStarted = result.getExperimentStarted();
		long experimentEnded = result.getExperimentEnded();
		long audioLength = result.getAudioLength();

		String insertWordSpotInfoExpQuery = "INSERT INTO WordSpotInfoExp ("
				+ "FILENAME,proccessinglength,EXPERIMENTSTARTED,EXPERIMENTENDED,AUDIOLENGTH, OPERATIONCOUNT) VALUES "
				+ "(''{0}'' ,{1,number,#},{2,number,#},{3,number,#},{4,number,#}, {5,number,#});";
		String queryWordSpotInfoExp = MessageFormat.format(
				insertWordSpotInfoExpQuery, fileName, proccessinglength,
				experimentStarted, experimentEnded, audioLength,
				result.getOperationCount());
		insert(queryWordSpotInfoExp);
	}

	public void insert(String query) {
		try {
			statement = connection.createStatement();
			statement.executeUpdate(query);
			connection.commit();
		} catch (SQLException e) {
			destroy();
			throw new ProcessingException(e);
		}
	}

	public void destroy() {
		try {
			if (!connection.isClosed()) {
				connection.commit();
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (statement != null) {
				try {
					statement.close();
				} catch (SQLException e) {
				} // nothing we can do
			}
			if (connection != null) {
				try {
					connection.close();
				} catch (SQLException e) {
				} // nothing we can do
			}
		}

	}

	public boolean isRecreate() {
		return recreate;
	}

	public void setRecreate(boolean recreate) {
		this.recreate = recreate;
	}
}
