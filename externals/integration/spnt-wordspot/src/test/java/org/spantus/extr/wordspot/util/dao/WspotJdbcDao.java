/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.spantus.extr.wordspot.util.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.MessageFormat;
import java.util.LinkedHashSet;
import java.util.Map.Entry;
import java.util.Set;

import org.spantus.core.beans.RecognitionResult;
import org.spantus.core.beans.SignalSegment;
import org.spantus.core.marker.Marker;
import org.spantus.exception.ProcessingException;
import org.spantus.extractor.impl.ExtractorEnum;
import org.spantus.utils.Assert;

/**
 *
 * @author mondhs
 */
public class WspotJdbcDao {

    Connection connection = null;
    Statement statement = null;
    boolean recreate = false;

    public void init() {
        try {
            Class.forName("org.hsqldb.jdbcDriver").newInstance();

            String url = "jdbc:hsqldb:hsql://localhost/spnt-exp";
            connection = DriverManager.getConnection(url, "sa", "");
            connection.setAutoCommit(true);

            statement = connection.createStatement();
            if (recreate) {
                String query = 
                         "DROP TABLE WordSpotInfoExp IF EXISTS;"
                                + "CREATE CACHED TABLE WordSpotInfoExp("
                                + "id BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 0) NOT NULL PRIMARY KEY,"
                                + "fileName VARCHAR(255) NOT NULL,"
                                + "proccessingLength BIGINT, "
                                + "experimentStarted BIGINT,"
                                + "experimentEnded  BIGINT,"
                                + "audioLength  BIGINT,"
                                + ");"                		
                		+ "DROP TABLE WordSpotFoundExp IF EXISTS;"
                        + "CREATE CACHED TABLE WordSpotFoundExp("
                        + "id BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 0) NOT NULL PRIMARY KEY,"
                        + "ekey VARCHAR(255) NOT NULL,"                        
                        + "fileName VARCHAR(255) NOT NULL,"
                        + "markerLabel VARCHAR(255),"
                        + "markerStart BIGINT,"
                        + "markerEnd BIGINT,"
                        + "foundStart BIGINT,"
                        + "foundEnd BIGINT,"
                        + "mfccVaue FLOAT);"
                        + "\n"
                        + "DROP TABLE WordSpotSampleExp IF EXISTS;"
                        + "CREATE CACHED TABLE WordSpotSampleExp("
                        + "id BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 0) NOT NULL PRIMARY KEY,"
                        + "ekey VARCHAR(255) NOT NULL UNIQUE,"
                        + "fileName VARCHAR(255) NOT NULL,"
                        + "markerLabel VARCHAR(255) NOT NULL,"                        
//                        + "proccessingLength BIGINT, "
//                        + "experimentStarted BIGINT,"
//                        + "experimentEnded  BIGINT,"
//                        + "audioLength  BIGINT,"
                        + "markerStart BIGINT,"
                        + "markerEnd BIGINT,"
                        + ");";
                statement.executeUpdate(query);
                connection.commit();
            }

        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | SQLException e) {
            destroy();
            throw new ProcessingException(e);
        }
    }

    public void save(WordSpotResult result) {
    	String fileName = result.getFileName();
    	insertExpInfo(result);
        
        Set<Marker> orignalMap = new LinkedHashSet<Marker>();
        for (Marker originalMarker : result.getOriginalMarker()) {
            String markerLabel = originalMarker.getLabel();
            Long markerStart = originalMarker.getStart();
            Long markerEnd = originalMarker.getEnd();
            orignalMap.add(originalMarker);
            markerLabel = markerLabel.replaceAll("[\'|-]", "");
            
            String insertWordSpotSampleExpQuery = "INSERT INTO WordSpotSampleExp ("
                    + "EKEY, FILENAME, MARKERLABEL,MARKERSTART,MARKEREND) VALUES "
                    + "(''{0}-{1}-{2}'', ''{0}'',  ''{1}'' ,{3,number,#},"
                    + "{4,number,#});";

            String queryWordSpotSampleExp = MessageFormat.format(insertWordSpotSampleExpQuery,
                    fileName, markerLabel,originalMarker.getId(), markerStart, markerEnd);

            insert(queryWordSpotSampleExp);
		}


        for (Entry<RecognitionResult, SignalSegment> recognitionResultEntry : result.getSegments().entrySet()) {

            RecognitionResult recognitionResult = recognitionResultEntry.getKey();
            SignalSegment signalSegment = recognitionResultEntry.getValue();


            Long foundStart = signalSegment.getMarker().getStart();
            Long foundEnd = signalSegment.getMarker().getEnd();
            String foundLabel = signalSegment.getMarker().getLabel();
            Double mfccVaue = recognitionResult.getDetails().getDistances().get(ExtractorEnum.MFCC_EXTRACTOR.name());
            Marker originalMarker = null;
            Long minDelta = Long.MAX_VALUE ;
            for (Marker iOriginalMarker : orignalMap) {
            	long delta = Math.abs(iOriginalMarker.getStart()-foundStart);
				if(delta<minDelta){
					minDelta=delta;
					originalMarker = iOriginalMarker;
				}
			}
            foundLabel = foundLabel.replaceAll("[\'|-]", "");
            
            if(originalMarker == null){
            	Assert.isTrue(originalMarker != null, "Not found for {0}", foundLabel);
            }
            
            Long markerStart = originalMarker.getStart();
            Long markerEnd = originalMarker.getEnd();

            String insertQuery = "INSERT INTO WordSpotFoundExp (EKEY, FILENAME, MARKERLABEL, MARKERSTART,MARKEREND,FOUNDSTART,FOUNDEND,MFCCVAUE) VALUES "
                    + "(''{0}-{1}-{2}'', ''{0}'' , ''{1}'',{3,number,#},"
                    + "{4,number,#},{5,number,#},{6,number,#},{7,number,#.###});";

            String queryWORDSPOTEXP = MessageFormat.format(insertQuery,
                    fileName, foundLabel,signalSegment.getMarker().getId(), markerStart, markerEnd, foundStart, foundEnd, mfccVaue);
            insert(queryWORDSPOTEXP);
        }
    }
    /**
     * 
     * @param result
     */
    private void insertExpInfo(WordSpotResult result) {
        String fileName = result.getFileName();
        long proccessinglength = result.getExperimentEnded() - result.getExperimentStarted();
        long experimentStarted = result.getExperimentStarted();
        long experimentEnded = result.getExperimentEnded();
        long audioLength = result.getAudioLength();
        
        String insertWordSpotInfoExpQuery = "INSERT INTO WordSpotInfoExp ("
                + "FILENAME,proccessinglength,EXPERIMENTSTARTED,EXPERIMENTENDED,AUDIOLENGTH) VALUES "
                + "(''{0}'' ,{1,number,#},{2,number,#},{3,number,#},{4,number,#});";
        String queryWordSpotInfoExp = MessageFormat.format(insertWordSpotInfoExpQuery,
                fileName,
                proccessinglength, experimentStarted, experimentEnded,
                audioLength);
        insert(queryWordSpotInfoExp);
	}

	public void insert(String query) {
        try {
            statement = connection.createStatement();
            statement.executeUpdate(query);
            connection.commit();
        } catch (SQLException e) {
            destroy();
            throw new ProcessingException(e);
        }
    }

    public void destroy() {
        try {
            if (!connection.isClosed()) {
                connection.commit();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (statement != null) {
                try {
                    statement.close();
                } catch (SQLException e) {
                } // nothing we can do
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (SQLException e) {
                } // nothing we can do
            }
        }

    }

    public boolean isRecreate() {
        return recreate;
    }

    public void setRecreate(boolean recreate) {
        this.recreate = recreate;
    }
}
