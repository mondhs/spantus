package org.spantus.exp.recognition.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.MessageFormat;
import java.util.Map;
import java.util.Map.Entry;

import org.spantus.exception.ProcessingException;
import org.spantus.exp.recognition.domain.QSegmentExp;
import org.spantus.utils.StringUtils;

import com.google.common.collect.Maps;

public class QSegmentExpHsqlDao implements QSegmentExpDao {
	private static final String LPCLABEL = "LPCLABEL";
	private static final String MFCCLABEL = "MFCCLABEL";
	public static final String MANUALNAME = "MANUALNAME";
	private static final String PLPLABEL = "PLPLABEL";
	Connection connection = null;
	Statement statement = null;
	boolean recreate = false;

	public void init() {
		try {
			Class.forName("org.hsqldb.jdbcDriver").newInstance();

			String url = "jdbc:hsqldb:hsql://localhost/spnt-exp";
			connection = DriverManager.getConnection(url, "sa", "");
			connection.setAutoCommit(true);

			statement = connection.createStatement();
			if (recreate) {
				String query = "DROP TABLE QSegmentExp IF EXISTS;"
						+

						"CREATE CACHED TABLE QSegmentExp("
						+ "id BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 0) NOT NULL PRIMARY KEY,"
						+ "length BIGINT,"
						+ "start BIGINT,"
						+ "wavFilePath VARCHAR(255) NOT NULL,"
						+ "markerLabel VARCHAR(255) NOT NULL,"
						+ "corpusEntryName VARCHAR(255) NOT NULL,"
						+ "manualName VARCHAR(255) NOT NULL,"
						+ "proceessTime BIGINT," 
						+ "loudnessLabel VARCHAR(255) NOT NULL," + "loudness FLOAT,"
						+ "spectralFluxLabel VARCHAR(255) NOT NULL," + "spectralFlux FLOAT," 
						+  "plpLabel VARCHAR(255) NOT NULL,"+ "plp FLOAT," 
						+  "lpcLabel VARCHAR(255) NOT NULL,"+ "lpc FLOAT,"
						+  "mfccLabel VARCHAR(255) NOT NULL,"+ "mfcc FLOAT," 
						+  "signalEntropyLabel VARCHAR(255) NOT NULL,"+ "signalEntropy FLOAT," 
						+ "timeStamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP"+ ");"
				// + "CREATE INDEX feature_idx on QSegmentExp(TOTALRESULT)"
				;
				statement.executeUpdate(query);
				connection.commit();
			}

		} catch (InstantiationException e) {
			destroy();
			throw new ProcessingException(e);
		} catch (IllegalAccessException e) {
			destroy();
			throw new ProcessingException(e);
		} catch (ClassNotFoundException e) {
			destroy();
			throw new ProcessingException(e);
		} catch (SQLException e) {
			destroy();
			throw new ProcessingException(e);
		}
	}
	

	protected String getInsertExperimentResulQuery() {
		String insertQuery = "INSERT INTO QSegmentExp"
				+ "(wavFilePath, start, length, markerLabel, corpusEntryName, manualName ,proceessTime,loudnessLabel, loudness, spectralFluxLabel, spectralFlux,plpLabel, plp, lpcLabel, lpc, mfccLabel, mfcc, signalEntropyLabel,  signalEntropy) VALUES"
				+ "(''{0}'',  {1,number,#}, {2,number,#},''{3}'', ''{4}'', ''{5}'', {6,number,#}, " +
						"''{7}'', {8,number,#.#}," +
						"''{9}'', {10,number,#.#}," +
						"''{11}'', {12,number,#.#}, " +
						"''{13}'',{14,number,#.#}, " +
						"''{15}'',{16,number,#.#}, " +
						"''{17}'',{18,number,#.#}" +
						");";
		return insertQuery;
	}
	
	public static final String REPORT_QUERY="select MANUALNAME, count(id) mcount from QSEGMENTEXP where ";
	public static final String REPORT_QUERY_GROUPING =		" GROUP By MANUALNAME   HAVING count(id) >5 ORDER by COUNT(id) desc";

	/**
	 * 
	 */
	public void  findMatches( String corpusName){
		
		StringBuilder criteria =  new StringBuilder();
		String currentRecognitionFeature= MANUALNAME;
		String separator = " ";
		
		criteria.append(separator).append("  {0} = MANUALNAME ");
		separator = " AND ";
		
//		if (StringUtils.hasText(recognitionFeature)) {
//			currentRecognitionFeature = recognitionFeature;
//		}
		if (StringUtils.hasText(corpusName)) {
			//criteria.append(separator).append("  CORPUSENTRYNAME={1} ");
			criteria.append(separator).append("  CORPUSENTRYNAME in ({1}) ");
			separator = " AND ";
		}
		
		String query = REPORT_QUERY + criteria + REPORT_QUERY_GROUPING;
		
		Map<String, Map<String, Integer>> results = Maps.newTreeMap();
		try {
			statement = connection.createStatement();
			 fetchResults(criteria, corpusName, results, MANUALNAME);
			 fetchResults(criteria, corpusName, results, PLPLABEL);
			 fetchResults(criteria, corpusName, results, MFCCLABEL);
			 fetchResults(criteria, corpusName, results, LPCLABEL);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		StringBuilder sb = new StringBuilder();
		sb.append("Label;MANUAL;PLPLABEL; MFCCLABEL; LPCLABEL\n");
		for (Entry<String, Map<String, Integer>> record : results.entrySet()) {
			sb.append(record.getKey()).append(";");
			String[] columns = new String[]{ PLPLABEL, MFCCLABEL, LPCLABEL};
			int manualInt = record.getValue().get(MANUALNAME);
			sb.append(manualInt).append(";");
			for (String column : columns) {
				Integer val = record.getValue().get(column);
				if(val == null){
					sb.append(";");
				}else{
					sb.append(val.doubleValue()/manualInt).append(";");
				}
				
			}
			sb.append("\n");
			
		}
		System.out.println(sb);
	}
/**
 * 
 * @param criteria
 * @param corpusName
 * @param results
 * @param segmentLabel
 * @throws SQLException
 */
	private void fetchResults(StringBuilder criteria, String corpusName, Map<String, Map<String, Integer>> results, String segmentLabel) throws SQLException {
		String query = REPORT_QUERY + criteria + REPORT_QUERY_GROUPING;
		query = 
				 MessageFormat.format(query, segmentLabel, "'"+corpusName + "'");
		System.out.println(query);
		ResultSet  rs = statement.executeQuery(query);
		 while (rs.next()) {
			 String segmentName = rs.getString(MANUALNAME);
			 Map<String, Integer> newMap = results.get(segmentName);
			 if(newMap == null){
				newMap = Maps.newTreeMap();
			 }
			 newMap.put(segmentLabel, rs.getInt("mcount"));
			 results.put(segmentName, newMap);
		 }		
	}


	public QSegmentExp save(QSegmentExp exp) {
		String query = MessageFormat.format(
				getInsertExperimentResulQuery(),
				exp.getWavFilePath(),exp.getStart(), exp.getLength(),
				exp.getMarkerLabel(), exp.getCorpusEntryName(),
				exp.getManualName(), exp.getProceessTime(),
				exp.getLoudnessLabel(), exp.getLoudness(),
				exp.getSpectralFluxLabel(), exp.getSpectralFlux(),
				exp.getPlpLabel(),  exp.getPlp(), 
				exp.getLpcLabel(), exp.getLpc(), 
				exp.getMfccLabel(), exp.getMfcc(), 
				exp.getSignalEntropyLabel(), exp.getSignalEntropy(), exp.getTimeStamp());
		try {
			statement = connection.createStatement();
			statement.executeUpdate(query);
			connection.commit();
		} catch (SQLException e) {
			destroy();
			throw new ProcessingException(e);
		}
		return exp;
	}

	public void destroy() {
		try {
			if(!connection.isClosed()){
				connection.commit();
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (statement != null) {
				try {
					statement.close();
				} catch (SQLException e) {
				} // nothing we can do
			}
			if (connection != null) {
				try {
					connection.close();
				} catch (SQLException e) {
				} // nothing we can do
			}
		}
	}

	public boolean isRecreate() {
		return recreate;
	}

	public void setRecreate(boolean recreate) {
		this.recreate = recreate;
	}

}
