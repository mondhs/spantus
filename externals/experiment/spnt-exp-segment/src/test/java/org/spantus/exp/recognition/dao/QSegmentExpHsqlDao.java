package org.spantus.exp.recognition.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.MessageFormat;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

import org.spantus.exception.ProcessingException;
import org.spantus.exp.recognition.domain.QSegmentExp;
import org.spantus.utils.StringUtils;

public class QSegmentExpHsqlDao implements QSegmentExpDao {
	private static final String LPCLABEL = "LPCLABEL";
	private static final String MFCCLABEL = "MFCCLABEL";
	public static final String MANUALNAME = "MANUALNAME";
	private static final String PLPLABEL = "PLPLABEL";
	Connection connection = null;
	Statement statement = null;
	boolean recreate = false;

	public void init() {
		try {
			Class.forName("org.hsqldb.jdbcDriver").newInstance();

			String url = "jdbc:hsqldb:hsql://localhost/spnt-exp";
			connection = DriverManager.getConnection(url, "sa", "");
			connection.setAutoCommit(true);

			statement = connection.createStatement();
			if (recreate) {
				String query = "DROP TABLE QSegmentExp IF EXISTS;"
						+

						"CREATE CACHED TABLE QSegmentExp("
						+ "id BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 0) NOT NULL PRIMARY KEY,"
						+ "length BIGINT," + "start BIGINT,"
						+ "wavFilePath VARCHAR(255) NOT NULL,"
						+ "markerLabel VARCHAR(255) NOT NULL,"
						+ "corpusEntryName VARCHAR(255) NOT NULL,"
						+ "manualName VARCHAR(255) NOT NULL,"
						+ "proceessTime BIGINT,"
						+ "loudnessLabel VARCHAR(255) NOT NULL,"
						+ "loudness FLOAT,"
						+ "spectralFluxLabel VARCHAR(255) NOT NULL,"
						+ "spectralFlux FLOAT,"
						+ "plpLabel VARCHAR(255) NOT NULL," + "plp FLOAT,"
						+ "lpcLabel VARCHAR(255) NOT NULL," + "lpc FLOAT,"
						+ "mfccLabel VARCHAR(255) NOT NULL," + "mfcc FLOAT,"
						+ "signalEntropyLabel VARCHAR(255) NOT NULL,"
						+ "signalEntropy FLOAT,"
						+ "timeStamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP"
						+ ");"
				// + "CREATE INDEX feature_idx on QSegmentExp(TOTALRESULT)"
				;
				statement.executeUpdate(query);
				connection.commit();
			}

		} catch (InstantiationException e) {
			destroy();
			throw new ProcessingException(e);
		} catch (IllegalAccessException e) {
			destroy();
			throw new ProcessingException(e);
		} catch (ClassNotFoundException e) {
			destroy();
			throw new ProcessingException(e);
		} catch (SQLException e) {
			destroy();
			throw new ProcessingException(e);
		}
	}

	protected String getInsertExperimentResulQuery() {
		String insertQuery = "INSERT INTO QSegmentExp"
				+ "(wavFilePath, start, length, markerLabel, corpusEntryName, manualName ,proceessTime,loudnessLabel, loudness, spectralFluxLabel, spectralFlux,plpLabel, plp, lpcLabel, lpc, mfccLabel, mfcc, signalEntropyLabel,  signalEntropy) VALUES"
				+ "(''{0}'',  {1,number,#}, {2,number,#},''{3}'', ''{4}'', ''{5}'', {6,number,#}, "
				+ "''{7}'', {8,number,#.#}," + "''{9}'', {10,number,#.#},"
				+ "''{11}'', {12,number,#.#}, " + "''{13}'',{14,number,#.#}, "
				+ "''{15}'',{16,number,#.#}, " + "''{17}'',{18,number,#.#}"
				+ ");";
		return insertQuery;
	}

	public static final String ALL_SEGMENTS_REPORT_QUERY = "select {0} count(id) mcount from QSEGMENTEXP   {1}";
	public Integer acceptThreshold = 90;

	
	public static final String DISTINCT_SEGMENTS_REPORT_QUERY = "select {0}  count(distinct(MANUALNAME)) mcount from QSEGMENTEXP where  not MARKERLABEL like ''D;%''  {1}";
	public static final String CORRECT_SYLABLE_SEGMENTS_REPORT_QUERY = "select {0} count(id) mcount from QSEGMENTEXP where MANUALNAME = ''<SYLLABLE>'' and not MARKERLABEL like ''D;%''  {1}";
	public static final String ERR_JOINED_SEGMENTS_REPORT_QUERY = "select {0} count(id) mcount from QSEGMENTEXP where LENGTH(MANUALNAME) > 2  and not MARKERLABEL like ''D;%''  {1}";
	public static final String ERR_NOIZE_SEGMENTS_REPORT_QUERY = "select {0} count(id) mcount from QSEGMENTEXP where MANUALNAME = '''' and not MARKERLABEL like ''D;%''  {1}";
	public static final String ERR_BREAK_SEGMENTS_REPORT_QUERY = "select {0} count(id) mcount from QSEGMENTEXP where  MARKERLABEL like ''D;%''  {1}";

	public static final String SUCC_RECONITION_SEGMENTS_REPORT_QUERY = "select {0} count(id) mcount from QSEGMENTEXP where "
			+ "MANUALNAME = ''<SYLLABLE_WAS>''  and  MFCCLABEL = ''<SYLLABLE_SAID>'' and MFCC < <ACCEPT_THRESHOLD> and not  MARKERLABEL like ''D;%''  {1}";

	public static final String SUCC_RECONITION_LIKE_SEGMENTS_REPORT_QUERY = "select {0} count(id) mcount from QSEGMENTEXP where "
			+ "MANUALNAME like ''%<SYLLABLE_WAS>''  and  MFCCLABEL like ''%<SYLLABLE_SAID>'' and LENGTH(MANUALNAME)<=2 and  LENGTH(MFCCLABEL)<=2 and MFCC < <ACCEPT_THRESHOLD>   and not  MARKERLABEL like ''D;%''  {1}";

	public static final String ERR_RECONITION_LIKE_NOISE_REPORT_QUERY = "select {0} count(id) mcount from QSEGMENTEXP where "
			+ "MANUALNAME like ''''  and  MFCCLABEL like ''%<SYLLABLE_SAID>''  and MFCC < <ACCEPT_THRESHOLD> and not  MARKERLABEL like ''D;%''  {1}";
	public static final String ALL_SEGMENTS_FOR_RECOGN_REPORT_QUERY = "select {0} count(id) mcount from QSEGMENTEXP  where "+
			" not (MARKERLABEL like ''D;%'' or " +
			" (LENGTH(MANUALNAME) > 2  and not MARKERLABEL like ''D;%''))  {1}";
	
	public static final String ERR_REJECTED_RECONITION_SEGMENTS_REPORT_QUERY = "select {0} count(id) mcount from QSEGMENTEXP where "
			+ " MFCC >= <ACCEPT_THRESHOLD> and LENGTH(MANUALNAME)<=2 and not  MARKERLABEL like ''D;%''  {1}";

	public static final String ERR_SEGMENT_TOTAL_QUERY = "select {0} count(id) mcount from QSEGMENTEXP where "
			+ "((LENGTH(MANUALNAME) > 2  and not MARKERLABEL like ''D;%'') or (MANUALNAME = '''' and not MARKERLABEL like ''D;%'') or (MARKERLABEL like ''D;%'') )   {1}";

	public static final String ERR_RECONITION_TOTAL_QUERY = "select {0} count(id) mcount from QSEGMENTEXP where "+
			"( (LENGTH(MANUALNAME)=2  and LENGTH(MFCCLABEL)=2  and not SUBSTR(MANUALNAME,2,1) =  SUBSTR(MFCCLABEL,2,1)) or (MANUALNAME ='''' AND  LENGTH(MFCCLABEL)<=2) ) "+
			" and MFCC < <ACCEPT_THRESHOLD> and not  MARKERLABEL like''D;%''  {1}";
	
	public static final String ERR_RECONITION_TOTAL_SYLLABLE_QUERY = "select {0} count(id) mcount from QSEGMENTEXP where "
			+ "( (LENGTH(MANUALNAME)=2  and LENGTH(MFCCLABEL)=2  and not MANUALNAME =  MFCCLABEL) or (MANUALNAME ='''' AND  LENGTH(MFCCLABEL)<=2) ) " +
			" and MFCC < <ACCEPT_THRESHOLD> and not  MARKERLABEL like''D;%''  {1}";

	/**
	 * 
	 */
	@Override
	public StringBuilder generateReport(String shouldBe, String[] syllabels) throws SQLException {
		StringBuilder sb = new StringBuilder();
		Map<String, String> reports = new LinkedHashMap<String, String>();
		
		String[] vovel = new String[] { "a", "e" ," "};

		segmentationReport(syllabels, reports);
		reports.put("B2", null);
		

		recognitionByVovel(vovel, reports);
		reports.put("B3", null);
		
		recognitionBySyllabels(syllabels, reports);
		reports.put("B4", null);
		
		reports.put("Segmentavimo klaidos", ERR_SEGMENT_TOTAL_QUERY);
		reports.put("Atpažinimo klaidos", ERR_RECONITION_TOTAL_QUERY);
		reports.put("Skiemenų atpažinimo klaidos", ERR_RECONITION_TOTAL_SYLLABLE_QUERY);


		boolean header = false;
		for (Entry<String, String> entry : reports.entrySet()) {
			if (entry.getValue() == null) {
				sb.append("\n");
				continue;
			}
			if (entry.getValue().contains("${shouldBe}")) {
				sb.append(entry.getKey()).append(",").append(shouldBe)
						.append("\n");
				continue;

			}
			System.out.println(entry.getKey());
			Map<Integer, Integer> result = fetchResults(entry.getValue());
			System.out.println();
			if (!header) {
				// sb.append("\n");
				// sb.append(",");
				// for (Integer key : result.keySet()) {
				// sb.append(key).append("dB,");
				// }
				sb.append("\n");
				header = true;
			}
			sb.append(entry.getKey()).append(",");
			for (Integer value : result.values()) {
				sb.append(value).append(",");
			}
			sb.append("\n");
		}
		return sb;
	}

	/**
	 * 
	 * @param vovel
	 * @param reports
	 */
	private void recognitionByVovel(String[] vovel, Map<String, String> reports) {
		for (String vovelWas : vovel) {
			
			String vovelWasQuery = SUCC_RECONITION_LIKE_SEGMENTS_REPORT_QUERY;
			
//			if(!StringUtils.hasText(vovelWas.trim())){
//				vovelWasQuery = vovelWasQuery.replaceAll("%<SYLLABLE_WAS>", "<SYLLABLE_WAS>").replaceAll("%<SYLLABLE_SAID>", "<SYLLABLE_SAID>");
//			}
			
			 vovelWasQuery = vovelWasQuery.replaceAll(
					"<SYLLABLE_WAS>", vovelWas).replaceAll(
					"<SYLLABLE_SAID>", vovelWas);
			
			reports.put(
					"Teisingai " + vovelWas + " ",vovelWasQuery
					);
		}
		for (String vovelWas : vovel) {
			for (String vovelSaid : vovel) {
				if (!vovelWas.equals(vovelSaid)  ) {
					String vovelWasQuery = SUCC_RECONITION_LIKE_SEGMENTS_REPORT_QUERY;
					if(!StringUtils.hasText(vovelSaid.trim())){
						vovelWasQuery = vovelWasQuery.replace("and LENGTH(MANUALNAME) = LENGTH(MFCCLABEL)", "");
						vovelWasQuery = vovelWasQuery.replaceAll("%<SYLLABLE_SAID>", "<SYLLABLE_SAID>");
					}
					if(!StringUtils.hasText(vovelWas.trim())){
						vovelWasQuery = vovelWasQuery.replace("and LENGTH(MANUALNAME) = LENGTH(MFCCLABEL)", "");
						vovelWasQuery = vovelWasQuery.replaceAll("%<SYLLABLE_WAS>", "<SYLLABLE_WAS>");
					}
					reports.put(
							"Klaidingai " + vovelWas + " kaip " + vovelSaid + " ",
							vovelWasQuery
									.replaceAll("<SYLLABLE_WAS>", vovelWas)
									.replaceAll("<SYLLABLE_SAID>", vovelSaid));
				}
			}
		}
//		for (String vovelWas : vovel) {
//			reports.put("Klaidingai triukšmas kaip " + vovelWas,
//					ERR_RECONITION_LIKE_NOISE_REPORT_QUERY.replaceAll(
//							"<SYLLABLE_SAID>", vovelWas));
//		}
		reports.put("Atsisakyta" + " ", ERR_REJECTED_RECONITION_SEGMENTS_REPORT_QUERY);
//		reports.put("Klaidingai apjungti skiemenys ",
//				ERR_JOINED_SEGMENTS_REPORT_QUERY);
//		reports.put("Klaidingai skiemenų trūkiai" + " ",
//				ERR_BREAK_SEGMENTS_REPORT_QUERY);
		reports.put("Viso aptikta segmentavime" + " ", ALL_SEGMENTS_FOR_RECOGN_REPORT_QUERY);
	}

	/**
	 * 
	 * @param syllabels
	 * @param reports
	 */
	private void recognitionBySyllabels(String[] syllabels,
			Map<String, String> reports) {
		for (String syllableWas : syllabels) {
			reports.put("Teisingai  "+
					syllableWas,
					SUCC_RECONITION_SEGMENTS_REPORT_QUERY.replaceAll(
							"<SYLLABLE_WAS>", syllableWas).replaceAll(
							"<SYLLABLE_SAID>", syllableWas));
		}

		for (String syllableWas : syllabels) {
			for (String syllableSaid : syllabels) {
				if (!syllableWas.equals(syllableSaid) ||!StringUtils.hasText(syllableSaid.trim() )) {
					reports.put("Neteisingai "+
							syllableWas + " kaip " + syllableSaid  + "  ",
							SUCC_RECONITION_SEGMENTS_REPORT_QUERY.replaceAll(
									"<SYLLABLE_WAS>", syllableWas).replaceAll(
									"<SYLLABLE_SAID>", syllableSaid));
				}
			}
		}
//		for (String syllableWas : syllabels) {
//			reports.put(
//					"Neteisingai triukšmas kaip " + syllableWas,
//					SUCC_RECONITION_SEGMENTS_REPORT_QUERY.replaceAll(
//							"<SYLLABLE_WAS>", "").replaceAll("<SYLLABLE_SAID>",
//							syllableWas));
//		}
		reports.put("Atsisakyta", ERR_REJECTED_RECONITION_SEGMENTS_REPORT_QUERY);
//		reports.put("Klaidingai apjungti skiemenys"  + "  ",
//				ERR_JOINED_SEGMENTS_REPORT_QUERY);
//		reports.put("Klaidingai skiemenų trūkiai"  + "  ",
//				ERR_BREAK_SEGMENTS_REPORT_QUERY);
//		reports.put("Viso aptikta segmentavime"  + "  ", ALL_SEGMENTS_REPORT_QUERY);
		reports.put("Viso aptikta segmentavime" + "  ", ALL_SEGMENTS_FOR_RECOGN_REPORT_QUERY);
	}

	/**
	 * 
	 * @param syllabels
	 * @param reports
	 */
	private void segmentationReport(String[] syllabels,
			Map<String, String> reports) {
		for (String string : syllabels) {
			if(!StringUtils.hasText(string.trim())){
				continue;
			}
			reports.put("Teisingai " + string + "",
					CORRECT_SYLABLE_SEGMENTS_REPORT_QUERY.replaceAll(
							"<SYLLABLE>", string));
		}
		reports.put("Klaidingai 2 skiemenys apjungti",
				ERR_JOINED_SEGMENTS_REPORT_QUERY);
		reports.put("Klaidingai aptiktas triukšmas",
				ERR_NOIZE_SEGMENTS_REPORT_QUERY);
		reports.put("Klaidingai skiemenų trūkiai",
				ERR_BREAK_SEGMENTS_REPORT_QUERY);
		// reports.put("Viso aptikta", ALL_SEGMENTS_REPORT_QUERY);
		// reports.put("Skirtingų segmentų tipų",
		// DISTINCT_SEGMENTS_REPORT_QUERY);
		reports.put("turėjo būti", "${shouldBe}");
	}

	/**
	 * 
	 * @param criteria
	 * @param corpusName
	 * @param results
	 * @param segmentLabel
	 * @throws SQLException
	 */
	private Map<Integer, Integer> fetchResults(String query)
			throws SQLException {
		// String query = REPORT_QUERY + criteria + REPORT_QUERY_GROUPING;
		
		String thresholdQuery = query.replaceAll("<ACCEPT_THRESHOLD>", ""+getAcceptThreshold());
		
		String pimpedQuery = MessageFormat.format(thresholdQuery,
				"CORPUSENTRYNAME snr,", "GROUP BY CORPUSENTRYNAME");
		Map<Integer, Integer> result = new TreeMap<Integer, Integer>();
		System.out.println(pimpedQuery);
		ResultSet rs = statement.executeQuery(pimpedQuery);
		result.put(0, 0);
		result.put(5, 0);
		result.put(10, 0);
		result.put(15, 0);
		result.put(30, 0);
		result.put(99999999, 0);
		while (rs.next()) {
			Integer snr = rs.getInt("snr");
			result.put(snr, rs.getInt("mcount"));
		}

		pimpedQuery = MessageFormat.format(thresholdQuery, "", "");
		System.out.println(pimpedQuery);
		rs = statement.executeQuery(pimpedQuery);
		while (rs.next()) {
			result.put(99999999, rs.getInt("mcount"));
		}

		return result;
	}



	public QSegmentExp save(QSegmentExp exp) {
		String query = MessageFormat.format(getInsertExperimentResulQuery(),
				exp.getWavFilePath(), exp.getStart(), exp.getLength(),
				exp.getMarkerLabel(), exp.getCorpusEntryName(),
				exp.getManualName(), exp.getProceessTime(),
				exp.getLoudnessLabel(), exp.getLoudness(),
				exp.getSpectralFluxLabel(), exp.getSpectralFlux(),
				exp.getPlpLabel(), exp.getPlp(), exp.getLpcLabel(),
				exp.getLpc(), exp.getMfccLabel(), exp.getMfcc(),
				exp.getSignalEntropyLabel(), exp.getSignalEntropy(),
				exp.getTimeStamp());
		try {
			statement = connection.createStatement();
			statement.executeUpdate(query);
			connection.commit();
		} catch (SQLException e) {
			destroy();
			throw new ProcessingException(e);
		}
		return exp;
	}

	public void destroy() {
		try {
			if (!connection.isClosed()) {
				connection.commit();
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (statement != null) {
				try {
					statement.close();
				} catch (SQLException e) {
				} // nothing we can do
			}
			if (connection != null) {
				try {
					connection.close();
				} catch (SQLException e) {
				} // nothing we can do
			}
		}
	}

	public boolean isRecreate() {
		return recreate;
	}

	public void setRecreate(boolean recreate) {
		this.recreate = recreate;
	}

	public Integer getAcceptThreshold() {
		return acceptThreshold;
	}

	public void setAcceptThreshold(Integer acceptThreshold) {
		this.acceptThreshold = acceptThreshold;
	}

}
